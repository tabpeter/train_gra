[["data-processing-and-preparation.html", "Chapter 9 Data processing and preparation 9.1 Start with a sketch 9.2 Libraries 9.3 Reading in the data 9.4 Making data ‘long form’", " Chapter 9 Data processing and preparation One of the most challenging aspects of a project can be preparing the data for analysis. In real life, our data seldom looks like something from mtcars: knitr::kable( head(mtcars[, 1:8], 10), booktabs = TRUE, caption = &#39;Canonical example of clean data&#39; ) Table 9.1: Canonical example of clean data mpg cyl disp hp drat wt qsec vs Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 Instead, I often receive data that looks like this: An example adapted from real unprocessed data Instead of Google searching how to handle each step of processing data like this, this chapter will offer a step-by-step outline of the whole game. I will show you what packages and strategies I used to prepare these data for analysis in R. 9.1 Start with a sketch When I need to process raw data, I like to begin by sketching the data frame I want to build. Here is a sketch of what I need this data set to look like for analysis: 9.2 Libraries After a sketch, I start with choosing some tools for working with color-coded Excel data. Beside each library I load, I’ll comment the reason I find it useful: 9.3 Reading in the data Here, I read in the data multiple ways to obtain different information. The first line creates raw, which reads in the data without any formatting information. This will make the phenotype columns have all NA values. I need the other raw_ objects to get that information into a workable form. raw &lt;- read_excel(path = &quot;data/unprocessed_data_example.xlsx&quot;) raw_cells &lt;- xlsx_cells(path = &quot;data/unprocessed_data_example.xlsx&quot;) raw_formats &lt;- xlsx_formats(path = &quot;data/unprocessed_data_example.xlsx&quot;) # has color codes raw_id &lt;- raw_cells[raw_cells$col == 1, c(&quot;address&quot;, &quot;row&quot;, &quot;col&quot;, &quot;character&quot;)] 9.4 Making data ‘long form’ My next step is to transform the data from wide to long. The purpose of this is to create visuals later downstream. # transform to long long1 &lt;- raw |&gt; pivot_longer(cols = Gene1:Gene10, names_to = &quot;gene&quot;, values_to = &quot;alleles&quot;) # split alleles into two columns long2 &lt;- long1 |&gt; mutate(allele1 = case_when( gene != &quot;Gene2&quot; ~ substr(alleles, 1,1), gene == &quot;Gene2&quot; ~ NA_character_ ), allele2 = case_when( gene != &quot;Gene2&quot; ~ substr(alleles, 2,2), gene == &quot;Gene2&quot; ~ NA_character_ )) |&gt; # fix column names to have uniform case rename_with(.fn = tolower) "],["work-with-color-codes.html", "Chapter 10 Work with color codes", " Chapter 10 Work with color codes Next, I need to fill in the phenotype information that is color-coded. The colors will be included in raw_formats as HEX codes (without the leading hashtag). colors &lt;- raw_formats$local$fill$patternFill$fgColor$rgb # NB: colors are given here in order of appearance on the sheet (reading top to bottom) To help me work with the color codes, I wrote a function called cells_by_color. As soon as you catch yourself being tempted to copy and paste a chunk of code several times, it is time to write a function!. This is the most important message of the tutorial. Data cleaning is a place where there is no room to be sloppy. #&#39; a function to return the cells of a given color #&#39; @param formats An object returned from tidyxl::xlsx_formats #&#39; @param cells An object returned from tidyxl::xlsx_cells #&#39; @param color The hex color WITHOUT the leading &quot;#&quot; mark #&#39; @return a tibble with the addresses of the cells in that color #&#39; cells_by_color &lt;- function(formats, cells, color){ colors &lt;- formats$local$fill$patternFill$fgColor$rgb cells[cells$local_format_id %in% which(colors == color), c(&quot;address&quot;, &quot;row&quot;, &quot;col&quot;)] } Now, to see my function in action: # NB: column M in raw data = phenotype 1 # column N in raw data = phenotype 2 # column O in raw data = phenotype 3 green &lt;- cells_by_color(formats = raw_formats, cells = raw_cells, color = &quot;FF92D050&quot;) |&gt; mutate(phen = case_when( substr(address, 1, 1) == &quot;M&quot; ~ &quot;phen1&quot;, substr(address, 1, 1) == &quot;N&quot; ~ &quot;phen2&quot;, substr(address, 1, 1) == &quot;O&quot; ~ &quot;phen3&quot; ), color = &quot;green&quot;) red &lt;- cells_by_color(formats = raw_formats, cells = raw_cells, color = &quot;FFFF0000&quot;) |&gt; mutate(phen = case_when( substr(address, 1, 1) == &quot;M&quot; ~ &quot;phen1&quot;, substr(address, 1, 1) == &quot;N&quot; ~ &quot;phen2&quot;, substr(address, 1, 1) == &quot;O&quot; ~ &quot;phen3&quot; ), color = &quot;red&quot;) yellow &lt;- cells_by_color(formats = raw_formats, cells = raw_cells, color = &quot;FFFFFF00&quot;) |&gt; mutate(phen = case_when( substr(address, 1, 1) == &quot;M&quot; ~ &quot;phen1&quot;, substr(address, 1, 1) == &quot;N&quot; ~ &quot;phen2&quot;, substr(address, 1, 1) == &quot;O&quot; ~ &quot;phen3&quot; ), color = &quot;yellow&quot;) With the color codes labeled, I am ready to create a data frame with both genotype and phenotype information: phen1 &lt;- bind_rows( red |&gt; filter(phen == &quot;phen1&quot;), green |&gt; filter(phen == &quot;phen1&quot;), yellow |&gt; filter(phen == &quot;phen1&quot;) ) |&gt; mutate(phen1 = case_when( color == &quot;green&quot; ~ 1, color == &quot;red&quot; ~ 0, color == &quot;yellow&quot; ~ 0.5 )) |&gt; right_join(raw_id, by = &quot;row&quot;) |&gt; select(c(&quot;character&quot;, &quot;phen1&quot;)) phen2 &lt;- bind_rows( red |&gt; filter(phen == &quot;phen2&quot;), green |&gt; filter(phen == &quot;phen2&quot;) ) |&gt; mutate(phen2 = case_when( color == &quot;green&quot; ~ 1, color == &quot;red&quot; ~ 0 )) |&gt; right_join(raw_id, by = &quot;row&quot;) |&gt; select(c(&quot;character&quot;, &quot;phen2&quot;)) phen3 &lt;- bind_rows( red |&gt; filter(phen == &quot;phen3&quot;), green |&gt; filter(phen == &quot;phen3&quot;) ) |&gt; mutate(phen3 = case_when( color == &quot;green&quot; ~ 1, color == &quot;red&quot; ~ 0 )) |&gt; right_join(raw_id, by = &quot;row&quot;) |&gt; select(c(&quot;character&quot;, &quot;phen3&quot;)) I will write one more function to help me with the last step: #&#39; a function to retrieve the Nth value in an strsplit() list #&#39; @param x The character to split #&#39; @param split The split #&#39; @param which The numeric value indicating which item to retrieve split_which &lt;- function(x, split, which){ split_x &lt;- strsplit(x, split) |&gt; lapply(function(l){l[which]}) return(unlist(split_x)) } Finally, I have: phen &lt;- full_join(phen1, phen2) |&gt; full_join(phen3) |&gt; rename(individual = character) |&gt; filter(individual != &quot;Individual&quot;) |&gt; # need numeric ID for pedigreemm functions mutate(id = split_which(individual, &quot;_&quot;, 2)) ## Joining with `by = join_by(character)` ## Joining with `by = join_by(character)` knitr::kable( head(phen, booktabs = TRUE, caption = &#39;Final product - ready to analyze/graph&#39; )) individual phen1 phen2 phen3 id Patient_02 0 0 1 02 Patient_03 0 0 0 03 Patient_05 0 0 0 05 Patient_06 0 0 1 06 Patient_07 0 0 0 07 Patient_08 0 1 1 08 "]]
